<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shyft: shyft::core::inverse_distance Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shyft
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">Shyft</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceshyft_1_1core_1_1inverse__distance.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">shyft::core::inverse_distance Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshyft_1_1core_1_1inverse__distance_1_1idw__timeaxis.html">idw_timeaxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special time axis for the IDW algorithms that utilizes the fact that we have a known, common timeaxis, where each period/time is identified by index. ref note on destination setter for the IDW.  <a href="classshyft_1_1core_1_1inverse__distance_1_1idw__timeaxis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1parameter.html">parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameter is a simple place-holder for IDW parameters  <a href="structshyft_1_1core_1_1inverse__distance_1_1parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1precipitation__model.html">precipitation_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a minimal precipitation model for IDW, PrecipitationModel::scale_computer provides the constant precipitation_gradient relaying it to the transform function through the compute() result. the PrecipitationModel::transform returns sourceValue (precip) + gradient*(d.z-s.z), that is, it tries to translate the precipitation at source into the destination, taking into account the precipitation gradient.  <a href="structshyft_1_1core_1_1inverse__distance_1_1precipitation__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1precipitation__parameter.html">precipitation_parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1radiation__model.html">radiation_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a minimal model for IDW, RadiationModel::scale_computer does nothing(returns 1.0) the RadiationModel::transform returns sourceValue (radiation) * destination.slope_factor(), that is, it tries to translate the radiation at source into the destination, taking into account the destination slopefactor (assume slopefactor 1.0 at source ?)  <a href="structshyft_1_1core_1_1inverse__distance_1_1radiation__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1rel__hum__model.html">rel_hum_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a minimal model for IDW, RelHumModel::scale_computer does nothing(returns 1.0) the RelHumModel::transform returns sourceValue ;.  <a href="structshyft_1_1core_1_1inverse__distance_1_1rel__hum__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__default__gradient__scale__computer.html">temperature_default_gradient_scale_computer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__gradient__scale__computer.html" title="temperature_gradient_scale_computer based on a number of geo-located temperature-sources, compute the temperature gradient. The algorithm uses the two valid points with highest/lowest z among the surrounding points. The minimum z-distance is set to 50m to ensure stable calculations. If the available points are less than two, or they do not meet the z-distance criteria, the default gradient is returned. ">temperature_gradient_scale_computer</a> that always returns default gradient based on a number of geo-located temperature-sources, compute the temperature gradient.  <a href="structshyft_1_1core_1_1inverse__distance_1_1temperature__default__gradient__scale__computer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__gradient__scale__computer.html">temperature_gradient_scale_computer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__gradient__scale__computer.html" title="temperature_gradient_scale_computer based on a number of geo-located temperature-sources, compute the temperature gradient. The algorithm uses the two valid points with highest/lowest z among the surrounding points. The minimum z-distance is set to 50m to ensure stable calculations. If the available points are less than two, or they do not meet the z-distance criteria, the default gradient is returned. ">temperature_gradient_scale_computer</a> based on a number of geo-located temperature-sources, compute the temperature gradient. The algorithm uses the two valid points with highest/lowest z among the surrounding points. The minimum z-distance is set to 50m to ensure stable calculations. If the available points are less than two, or they do not meet the z-distance criteria, the default gradient is returned.  <a href="structshyft_1_1core_1_1inverse__distance_1_1temperature__gradient__scale__computer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__model.html">temperature_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a minimal temperature model for the IDW algorithm, providing functionality for transformation of source temperature to destination location using computed temperature gradient, based on nearby sources for that temperature location. TODO: Add more robust handling for source stations, value range etc.  <a href="structshyft_1_1core_1_1inverse__distance_1_1temperature__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1temperature__parameter.html">temperature_parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For temperature inverse distance, also provide default temperature gradient to be used when the gradient can not be computed.  <a href="structshyft_1_1core_1_1inverse__distance_1_1temperature__parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1wind__speed__model.html">wind_speed_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a minimal model for IDW, WindSpeedModel::scale_computer does nothing(returns 1.0) the WindSpeedModel::transform returns sourceValue ;.  <a href="structshyft_1_1core_1_1inverse__distance_1_1wind__speed__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a136555db20a046dc420eb559ea54ed16"><td class="memTemplParams" colspan="2">template&lt;class M , class S , class D , class T , class P , class F &gt; </td></tr>
<tr class="memitem:a136555db20a046dc420eb559ea54ed16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshyft_1_1core_1_1inverse__distance.html#a136555db20a046dc420eb559ea54ed16">run_interpolation</a> (S source_begin, S source_end, D destination_begin, D destination_end, const T &amp;timeAxis, const P &amp;<a class="el" href="structshyft_1_1core_1_1inverse__distance_1_1parameter.html">parameter</a>, F &amp;&amp;dest_set_value)</td></tr>
<tr class="memdesc:a136555db20a046dc420eb559ea54ed16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse Distance Weighted Interpolation The Inverse Distance Weighted algorithm.  <a href="#a136555db20a046dc420eb559ea54ed16">More...</a><br /></td></tr>
<tr class="separator:a136555db20a046dc420eb559ea54ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964c302f85e9b87483db3a2dd48f765f"><td class="memTemplParams" colspan="2">template&lt;typename IDWModel , typename IDWModelSource , typename ApiSource , typename P , typename D , typename ResultSetter , typename TimeAxis &gt; </td></tr>
<tr class="memitem:a964c302f85e9b87483db3a2dd48f765f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshyft_1_1core_1_1inverse__distance.html#a964c302f85e9b87483db3a2dd48f765f">run_interpolation</a> (const TimeAxis &amp;ta, ApiSource const &amp;api_sources, const P &amp;parameters, D &amp;cells, ResultSetter &amp;&amp;result_setter, int ncore=-1)</td></tr>
<tr class="memdesc:a964c302f85e9b87483db3a2dd48f765f"><td class="mdescLeft">&#160;</td><td class="mdescRight">run interpolation step, for a given IDW model, sources and parameters. run_idw_interpolation of supplied sources to destination locations/cells, over a range as specified by timeaxis, based on supplied templatized parameters.  <a href="#a964c302f85e9b87483db3a2dd48f765f">More...</a><br /></td></tr>
<tr class="separator:a964c302f85e9b87483db3a2dd48f765f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a136555db20a046dc420eb559ea54ed16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136555db20a046dc420eb559ea54ed16">&#9670;&nbsp;</a></span>run_interpolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class S , class D , class T , class P , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void shyft::core::inverse_distance::run_interpolation </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>destination_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>destination_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>timeAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>dest_set_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse Distance Weighted Interpolation The Inverse Distance Weighted algorithm. </p>
<p>Adopted/extracted from Enki method idwtemp by Sjur Kolberg/Sintef.</p>
<p>Transforms a set of time-series data at given source locations (X,Y,Z) to a new set of time-series data at some target (grid) locations (X,Y,Z) Using a weighted average of max n closest neighbors with available data to each target location.</p>
<p>The algorithm does not use neighbor locations that exceeds the maximum distance.</p>
<p>The algorithm can calculate and use the gradient for temperature data (as well as default fallback gradient ) to height adjust source temperatures to target temperature level. Ref. to M, Model template parameter for details.</p>
<p>notice that the last argument to the function is a setter function that takes D:value_type, size_t ix and value. This implies that currently the Timeaxis should just return size_t for (), - later we can fix this to be the return_type of function-expression of the timeaxis(). Until then, the IDWTimeAxis template is supplied at the end of this file to ease mapping a TimeAxis that conforms to average_accessor/value standards. Ref to IDWTest file for example</p>
<p>Preconditions:</p><ol type="1">
<li>There should be at least one source location with a valid value for all t.</li>
<li>Possible actions if not satisfied: set NaN at the output</li>
<li>Minimum distance unit is 1 { because we optimize using (x² + y² + z²) instead of sqrt(x² + y² + z²) }</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>iterator Source (location) Type that implements:<ol type="1">
<li>S.geo_point() const &ndash;&gt; 3D point, x,y,z, specifies the location</li>
<li>S.value(type of T operator(i) ) -&gt; returns value at the i'th period of timeaxis </li>
</ol>
</td></tr>
    <tr><td class="paramname">D</td><td>iterator Destination (location/area) Type that implements:<ol type="1">
<li>D.geo_point() const &ndash;&gt; 3D point, x,y,z etc.. (needed for calc dist, and height corrected temp)</li>
<li>D.set_value(type of T.operator(i), double value), function that is called to provide the computed value at the i'th timestep</li>
<li>other requirements dependent on the Model class could apply (like radiation slope factor, etc.) </li>
</ol>
</td></tr>
    <tr><td class="paramname">P</td><td>Parameters for the algorithm, that supplies :<ol type="1">
<li>P.max_distance const &ndash;&gt; double, - locations outside this distance is not available</li>
<li>P.max_members const &ndash;&gt; size_t, - max number of members to use in weight</li>
<li>P.distance_measure_factor &ndash;&gt; double, - as in pow(x, distance_measure_factor)</li>
<li>P.zscale &ndash;&gt; double, - scaling z for distance computing </li>
</ol>
</td></tr>
    <tr><td class="paramname">T</td><td>TimeAxis providing:<ol type="1">
<li>T.size() const &ndash;&gt; size_t, number of non-overlapping time intervals</li>
<li>T(const size_t i) const &ndash;&gt; period of a type, that is passed into type with start, end</li>
</ol>
</td></tr>
    <tr><td class="paramname">M</td><td>Temperature, Radiation, Precipitation Model providing:<ol type="1">
<li>M::scale_computer, a class that accepts a P parameter in the constructor. if M::scale_computer.is_source_based() is true, then for each destination cell, it will add valid sources for that cell, then call compute to compute the scaleValue that are passed into the M::transform function as described below. This allows us to create models that compute temperature gradient based on the same sources that we use for interpolating temperature into each cell. Ref. to Model classes for more details.</li>
<li>M::distance_measure, a static method that accepts three arguments; a,b of type of S|D.geo_point() and a measure parameter f, and returns the squared distance</li>
<li>M::transform(sourcevalue, scalevalue, const S &amp;source, const D&amp; destination), &ndash;&gt; source value transformed to destination level</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>BayesianKriging for more advanced interpolation </dd></dl>

<p class="definition">Definition at line <a class="el" href="inverse__distance_8h_source.html#l00142">142</a> of file <a class="el" href="inverse__distance_8h_source.html">inverse_distance.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceshyft_1_1core_1_1inverse__distance_a136555db20a046dc420eb559ea54ed16_cgraph.png" border="0" usemap="#namespaceshyft_1_1core_1_1inverse__distance_a136555db20a046dc420eb559ea54ed16_cgraph" alt=""/></div>
<map name="namespaceshyft_1_1core_1_1inverse__distance_a136555db20a046dc420eb559ea54ed16_cgraph" id="namespaceshyft_1_1core_1_1inverse__distance_a136555db20a046dc420eb559ea54ed16_cgraph">
<area shape="rect" id="node2" href="namespaceshyft_1_1timeseries.html#a4fa091ae89d99e00daff8f0821576893" title="shyft::timeseries::min" alt="" coords="235,13,383,39"/>
</map>
</div>

</div>
</div>
<a id="a964c302f85e9b87483db3a2dd48f765f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964c302f85e9b87483db3a2dd48f765f">&#9670;&nbsp;</a></span>run_interpolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IDWModel , typename IDWModelSource , typename ApiSource , typename P , typename D , typename ResultSetter , typename TimeAxis &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void shyft::core::inverse_distance::run_interpolation </td>
          <td>(</td>
          <td class="paramtype">const TimeAxis &amp;&#160;</td>
          <td class="paramname"><em>ta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApiSource const &amp;&#160;</td>
          <td class="paramname"><em>api_sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultSetter &amp;&amp;&#160;</td>
          <td class="paramname"><em>result_setter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncore</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>run interpolation step, for a given IDW model, sources and parameters. run_idw_interpolation of supplied sources to destination locations/cells, over a range as specified by timeaxis, based on supplied templatized parameters. </p>
<dl class="section note"><dt>Note</dt><dd>this is run in multicore mode, and it it safe because each thread, works on private or const data, and writes to different cells.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IDWModel</td><td>IDW model class, ref. IDW.h </td></tr>
    <tr><td class="paramname">IDWModelSource</td><td>IDW source class, ref IDW.h for requirements. </td></tr>
    <tr><td class="paramname">ApiSource</td><td>Api source, ref EnkiApiServiceImpl.h </td></tr>
    <tr><td class="paramname">P</td><td>IDW parameter, specific for a given model, ref IDW.h </td></tr>
    <tr><td class="paramname">D</td><td>IDW destination ref IDW.h </td></tr>
    <tr><td class="paramname">ResultSetter</td><td>lambda for writing results back to destination, (Destination,size_t idx,double value) </td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>make a vector of ts-accessors for the sources. Notice that this vector needs to be modified, since the accessor 'remembers' the last position. It is essential for performance, -but again-, then each thread needs it's own copy of the sources. Since the accessors just have a const <em>reference</em> to the underlying TS; there is no memory involved, so copy is no problem.</li>
</ol>
<ul>
<li>and figure out a suitable ncore number. Using single cpu 4..8 core shows we can have more threads than cores, and gain speed.</li>
</ul>
<ol type="1">
<li>Create a set of futures, for the threads that we want to run</li>
</ol>
<p>spawn a thread to run IDW on this part of the cells, using <em>all</em> sources (later we could speculate in sources needed)</p>
<p>capture src by value, we <em>want</em> a copy of that..</p>
<ol type="1">
<li>wait for the IDW computation threads to end. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="inverse__distance_8h_source.html#l00498">498</a> of file <a class="el" href="inverse__distance_8h_source.html">inverse_distance.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceshyft.html">shyft</a></li><li class="navelem"><a class="el" href="namespaceshyft_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespaceshyft_1_1core_1_1inverse__distance.html">inverse_distance</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
